\appendix
\chapter{MATLAB code}
\label{chap:appendixMatlab}

In this appendix the main MATLAB code used for the modelling and controller design of the self-balancing robot is reported.

\begin{lstlisting}[language=Matlab, caption=MATLAB code for PID tuning, label=lst:02_pidTuning, style=mystyle]
%% Self-balancing robot parameters

% Using stand-alone model of DC motor and inverse pendulum to derive transfer function
clc;
clearvars;
% Inverse pendulum data
% [Kg] total mass, considering also motors and battery
m = 0.1; 
% [m/s^2] gravity acceleration   
g = 9.81;   
% [m] length of the pendulum
l = 0.08;    
% [Kg*m^2] moment of inertia of inverse pendulum
J = m*l^2;  

% DC motor parameters
% [ohm] measured resistance
R = 3.5;    
% [H] estimated from comparison with similar motors
L = 50e-6;    
% [V*s] torque costant (Va_max-Ra*Ia)*1/Omega_max
KePhi = 0.336;  
% gear ratio
k_gear = 120;   

%% Transfer functions
s = tf('s');
% between torque to angle of the inverse pendulum
G_torq_ang = (1/J) *(1/(s^2 - g/l));
figure('Name', 'Transfer function of the inverse pendulum');
bode(G_ang_torq);

% between voltage to torque of the DC motor
G_volt_torq = KePhi * k_gear/(R + L*s); 
figure('Name', 'Transfer function of the DC motor');
bode(G_torq_volt);

% total transfer function
G_sys = G_volt_torq*G_torq_ang;

%% Requirements: tempo di salita e overshoot
% rise time
ts = 50e-3;
% overshoot choosen to be under a safe margin of maximum voltage of DC motors, that is 7.5V
M = 0.15;

% Crossover frequency and phase margin
fct = 2/(ts*2*pi);
pmt = 1.04 - 0.8*M;

% PID tuning options
opt = pidtuneOptions;
opt.PhaseMargin = 180*pmt/pi;

% PID controller design, with filter to reduce noise in derivative action
gi = pidtune(G_sys, 'pidf', 2*pi*fct, opt);

% Regulator transfer function
G_reg = gi.Kp + gi.Ki/s + gi.Kd*s/(1+s*gi.Tf);

fprintf('PID parameters: Kp %.4f, Ki %.4f, Kd %.4f, Tf %.2f [msec] \n', gi.Kp, gi.Ki, gi.Kd, gi.Tf*1e3);

[Nreg, Dreg] = tfdata(G_reg, 'v'); 
margin(G_reg*G_sys);
grid on;
\end{lstlisting}