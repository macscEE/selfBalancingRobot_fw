\begin{chapter}{Modelling and simulation}
\label{chap_02:modelling}
Now that we described the hardware components of our self-balancing robot in Chapter \ref{ch:01_introduction}, we can proceed to
model the system and simulate it's behavior in MATLAB/Simulink environment.

\section{Physical model}

The best way to model a self-balancing robot is to treat it as a \textit{inverse pendulum}, like the one reported in Figure \ref{fig:02_inversePendulum}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.25\linewidth]{figures/01_introduction/inverse_pendulum.pdf}
    \caption{Inverse pendulum schematic representation}
\label{fig:02_inversePendulum}
\end{figure}

Where:
\begin{itemize}
    \item $m$ is the mass of the pendulum
    \item $\ell$ is the length of the pendulum
    \item $\theta$ is the angle of the pendulum with respect to the vertical axis
    \item $\tau$ is the torque applied to the base of the pendulum 
\end{itemize}

\noindent
The equations that govern the motion of the inverse pendulum can be derived using Newton's laws.  
\begin{equation}
    m  \ell^2  \ddot{\theta}(t) = mg\ell sin(\theta) + \tau(t)
    \label{eq:02_equationInvPend}
\end{equation}

\noindent   
Where $g$ is the acceleration due to gravity and $\ddot{\theta}(t)$ is the angular acceleration of the pendulum.
To linearize the equation \ref{eq:02_equationInvPend}, we can use the small angle approximation, which states that for small angles (in radians), $sin(\theta) \approx \theta$.
This leads to the following linearized equation:

\begin{equation}
    m  \ell^2  \ddot{\theta}(t) = mg\ell \theta + \tau(t)
\label{eq:02_equationInvPendLinear}
\end{equation}

\noindent
From equation \ref{eq:02_equationInvPendLinear}, we can derive the transfer function of the system by taking 
the Laplace transform, assuming zero initial conditions:

\begin{equation}
    G_{pendulum}(s) = \frac{\theta(s)}{\tau(s)} = \frac{ \frac{1}{m \ell ^2} }{s^2 - \frac{g}{\ell}}
\label{eq:02_transferFunctionInvPend}
\end{equation}

\noindent
In equation \ref{eq:02_transferFunctionInvPend} we can see that the system has 
two poles at $s = \pm \sqrt{\frac{g}{\ell}}$, indicating that the system is unstable, as one of the poles is in the right half of the s-plane.

\section{DC motor modelling}

To model the DC motors used in our project, we can use the following equations that describe the electrical and mechanical dynamics of a DC motor:

\begin{equation}
    v(t) = L \frac{di(t)}{dt} + R i(t) + K_{\phi} \omega(t)
\label{eq:02_dcMotorElectrical}
\end{equation}

\noindent
By applying the Laplace transform to equation \ref{eq:02_dcMotorElectrical}, and
considering also the gear ratio $K_G = 120$ we obtain:

\begin{equation}
   G_{motor}(s) = \frac{\tau(s)}{v(s)}  = k_G \cdot \frac{K_\phi}{R + sL}
\end{equation}
\label{eq:02_dcMotorTransferFunction}
\end{chapter}

The obtained transfer function is a first order system.

\section{Complete model}

The complete model is the product of the two transfer functions obtained: we have to consider
that we do not consider the \textit{back EMF} of the motor in the transfer function: 
this is a simplification of the model.
In Figure \ref{fig:02_blockDiagram} the complete block diagram is reported, where $G(s) =  G_{pendulum}(s) \cdot G_{motor}(s) = 
\frac{\theta(s)}{v(s)}$.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{figures/02_modelling/blockDiagram.pdf}
    \caption{Complete block diagram of the self-balancing robot model}
\label{fig:02_blockDiagram}
\end{figure}

\section{Controller design}
Now that we have the complete transfer function of the system we can 
design the controller: we will use a \textit{PID controller}.
The PID controller has the following transfer function:
\begin{equation}
    G_{PID}(s) = K_P + \frac{K_I}{s} + K_D s
\end{equation}

\noindent
Where $K_P$, $K_I$ and $K_D$ are the proportional, integral and derivative gains respectively.
We want a controller such that the rise time of the closed loop system is around $50ms$ and the overshoot is less than $15\%$:
rise time is choosen in order to have a fast response of the system, while overshoot is limited in order to avoid that the motors 
broke due to overvoltage.  
We choose to let an automatic tuning \textit{MATLAB} function to find the best values for the PID gains:

\begin{lstlisting}[language=Matlab, caption=MATLAB code for PID tuning, label=lst:02_pidTuning, style=mystyle]
% rise time
ts = 50e-3;
% overshoot choosen to be under a safe margin of maximum voltage of DC motors, that is 7.5V
M = 0.15;

% Crossover frequency and phase margin
fct = 2/(ts*2*pi);
pmt = 1.04 - 0.8*M;

% PID tuning options
opt = pidtuneOptions;
opt.PhaseMargin = 180*pmt/pi;

% PID controller design
gi = pidtune(G_sys, 'pid', 2*pi*fct, opt);
\end{lstlisting}

The obtained parameters are:
\begin{itemize}
    \item $K_P = 0.0361$
    \item $K_I = 0.1412$
    \item $K_D = 0.0023$
\end{itemize}

\section{Simulation of the model}
Now that we have the complete linearized model of the system, we can evaluate
its behavior with a step response: we impose a step of $20^{\circ}$, simulating a small disturbance that makes the robot tilt of $20^{\circ}$ from the vertical position.
The step response is reported in Figure \ref{fig:02_stepResponse}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/02_modelling/Step response of the closed loop system.pdf}
    \caption{Step response of the closed loop system with PID controller}
\label{fig:02_stepResponse}
\end{figure}