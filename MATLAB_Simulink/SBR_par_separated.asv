%% Self-balancing robot parameters v2

% Using stand-alone model of DC motor and inverse pendulum to derive
% transfer function

clc;
clearvars;

% Motor: DFRobot DC Transmission Motor with Encoder - 6V - 160RPM

% Inverse pendulum data
m = 0.3;    % [Kg] total mass, considering also motors and battery
g = 9.81;   % [m/s^2] gravity acceleration
l = 0.25;    % [m] length of the pendulum
J = m*l^2;  % [Kg*m^2] moment of inertia of inverse pendulum

% DC motor parameters
R = 3.5;    % [ohm] measured resistance
L = 50e-6;   % [H] to be measured, stimata da ChatGPT
KePhi = 0.336; % [V*s] torque costant (Va_max-Ra*Ia)*1/Omega_max 
k_gear = 120;   % gear ratio

%% Transfer functions

s = tf('s');

% between torque to angle of the inverse pendulum
G_torq_ang = 1/(J*s^2 - m*g*l);
% figure('Name', 'Transfer function of the inverse pendulum');
% bode(G_ang_torq);

% between voltage to torque of the DC motor
G_volt_torq = KePhi * k_gear/(R + L*s);  % Transfer function from voltage to torque
% figure('Name', 'Transfer function of the DC motor');
% bode(G_torq_volt);

% total transfer function
G_sys = G_volt_torq*G_torq_ang;

%% Requirements: tempo di salita e overshoot

ts = 1; % rise time
M = 0.15;  % overshoot: percentuale 7.5/6 (massima tensione che può accettare) = 0.2 -> margine di sicurezza

fct = 2/(ts*2*pi);
pmt = 1.04 - 0.8*M;

opt = pidtuneOptions;
opt.PhaseMargin = 180*pmt/pi;

[gi, info] = pidtune(G_torq_ang, 'pidf', 2*pi*fct, opt);    % 'pidf' così ho il filtro in HF

G_reg = gi.Kp + gi.Ki/s + gi.Kd*s/(1+s/gi.Tf);

fprintf('PID parameters: Kp %.2f, Ki %.2f, Kd %.2f, Tf %.2f [microsec] \n', gi.Kp, gi.Ki, gi.Kd, gi.Tf*1e6);

[Nreg, Dreg] = tfdata(G_reg, 'v');    % 'v' per averceli in vettore
%margin(G_reg*G_sys);
%grid on;

step(G_sys,);
% %% chatgpt
% 
% % Parametri pendolo
% m = 0.2;       % massa pendolo [kg]
% l = 0.3;       % lunghezza [m]
% g = 9.81;      % gravità [m/s^2]
% I = m*l^2;     % momento d'inerzia [kg*m^2]
% 
% % Parametri motore DC
% R = 2;         % resistenza [Ohm]
% L = 0.01;      % induttanza [H]
% Kt = 0.05;     % costante di coppia [Nm/A]
% Kb = 0.35;     % costante contro-EMF [V*s/rad]
% 
% % Funzione di trasferimento pendolo + motore
% % tau(s) = Kt/(L s + R) * (V(s) - Kb s Theta(s))
% % Pendolo: I s^2 Theta - m g l Theta = tau
% s = tf('s');
% 
% P_motor = Kt/(L*s + R);                       % motore da V a tau
% P_pendulum = 1/(I*s^2 - m*g*l);               % pendolo
% % Sistema completo: Theta/V
% P = feedback(P_motor*P_pendulum, Kb*s);       % retroazione interna motore
% 
% % Progetto PID con pidtune
% C = pidtune(P,'PID');                          % PID automatico
% 
% % Sistema in retroazione unitaria
% sys_cl = feedback(C*P,1);
% 
% % Simulazione condizione iniziale
% 
% sys_cl_ss = ss(sys_cl);  % converti in spazio di stato
% theta0 = 0.1;             % deviazione iniziale [rad]
% x0 = [theta0; 0; 0; 0];   % vettore di stato (dimensione adattata)
% t = 0:0.001:5;
% [y,t,x] = initial(sys_cl_ss, x0, t);
% 
% figure;
% plot(t,y,'LineWidth',2);
% xlabel('Tempo [s]');
% ylabel('\theta [rad]');
% title('Pendolo inverso stabilizzato (spazio di stato)');
% grid on;
% % Mostra guadagni PID
% C